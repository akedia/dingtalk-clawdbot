import https from "node:https";
import http from "node:http";
import fs from "node:fs";
import path from "node:path";
import os from "node:os";

const DINGTALK_API_BASE = "https://api.dingtalk.com/v1.0";
const DINGTALK_OAPI_BASE = "https://oapi.dingtalk.com";

/** Cache access tokens per clientId */
const tokenCache = new Map<string, { token: string; expiresAt: number }>();

function jsonPost(url: string, body: any, headers?: Record<string, string>): Promise<any> {
  return new Promise((resolve, reject) => {
    const data = JSON.stringify(body);
    const urlObj = new URL(url);
    const mod = urlObj.protocol === "https:" ? https : http;
    const req = mod.request(urlObj, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(data),
        ...headers,
      },
    }, (res) => {
      let buf = "";
      res.on("data", (chunk: any) => { buf += chunk; });
      res.on("end", () => {
        try { resolve(JSON.parse(buf)); }
        catch { resolve({ raw: buf }); }
      });
    });
    req.on("error", reject);
    req.write(data);
    req.end();
  });
}

export async function getDingTalkAccessToken(clientId: string, clientSecret: string): Promise<string> {
  const cached = tokenCache.get(clientId);
  if (cached && cached.expiresAt > Date.now() + 60_000) {
    return cached.token;
  }
  const res = await jsonPost(`${DINGTALK_API_BASE}/oauth2/accessToken`, {
    appKey: clientId,
    appSecret: clientSecret,
  });
  if (!res.accessToken) {
    throw new Error(`DingTalk token error: ${JSON.stringify(res)}`);
  }
  tokenCache.set(clientId, {
    token: res.accessToken,
    expiresAt: Date.now() + (res.expireIn ?? 7200) * 1000,
  });
  return res.accessToken;
}

/** Send reply via sessionWebhook (preferred, no auth needed) */
export async function sendViaSessionWebhook(
  sessionWebhook: string,
  text: string,
): Promise<{ ok: boolean }> {
  const res = await jsonPost(sessionWebhook, {
    msgtype: "text",
    text: { content: text },
  });
  return { ok: res?.errcode === 0 || !res?.errcode };
}

/** Send markdown via sessionWebhook */
export async function sendMarkdownViaSessionWebhook(
  sessionWebhook: string,
  title: string,
  text: string,
): Promise<{ ok: boolean }> {
  const res = await jsonPost(sessionWebhook, {
    msgtype: "markdown",
    markdown: { title, text },
  });
  return { ok: res?.errcode === 0 || !res?.errcode };
}

/** Send message via REST API (proactive/outbound, requires token) */
export async function sendDingTalkRestMessage(params: {
  clientId: string;
  clientSecret: string;
  robotCode: string;
  userId?: string;
  conversationId?: string;
  text: string;
}): Promise<{ ok: boolean }> {
  const token = await getDingTalkAccessToken(params.clientId, params.clientSecret);
  const headers = { "x-acs-dingtalk-access-token": token };

  if (params.userId) {
    const res = await jsonPost(
      `${DINGTALK_API_BASE}/robot/oToMessages/batchSend`,
      {
        robotCode: params.robotCode,
        userIds: [params.userId],
        msgKey: "sampleText",
        msgParam: JSON.stringify({ content: params.text }),
      },
      headers,
    );
    if (res?.errcode && res.errcode !== 0) {
      throw new Error(`DingTalk DM send error: ${JSON.stringify(res)}`);
    }
    return { ok: !!res?.processQueryKey || !res?.code };
  }

  if (params.conversationId) {
    const res = await jsonPost(
      `${DINGTALK_API_BASE}/robot/groupMessages/send`,
      {
        robotCode: params.robotCode,
        openConversationId: params.conversationId,
        msgKey: "sampleText",
        msgParam: JSON.stringify({ content: params.text }),
      },
      headers,
    );
    if (res?.errcode && res.errcode !== 0) {
      throw new Error(`DingTalk group send error: ${JSON.stringify(res)}`);
    }
    return { ok: !!res?.processQueryKey || !res?.code };
  }

  throw new Error("Either userId or conversationId required");
}

/** Probe DingTalk connection by getting an access token */
export async function probeDingTalk(
  clientId: string,
  clientSecret: string,
): Promise<{ ok: boolean; error?: string }> {
  try {
    await getDingTalkAccessToken(clientId, clientSecret);
    return { ok: true };
  } catch (err) {
    return { ok: false, error: String(err) };
  }
}

/** User info cache - persisted to local file */
const USER_CACHE_FILE = path.join(os.homedir(), ".clawdbot", "extensions", "dingtalk", ".cache", "users.json");
let userCache: Map<string, { name: string; avatar?: string }> | null = null;

function loadUserCache(): Map<string, { name: string; avatar?: string }> {
  if (userCache) return userCache;

  try {
    if (fs.existsSync(USER_CACHE_FILE)) {
      const data = fs.readFileSync(USER_CACHE_FILE, "utf-8");
      const obj = JSON.parse(data);
      userCache = new Map(Object.entries(obj));
      return userCache;
    }
  } catch (err) {
    console.warn("[dingtalk] Failed to load user cache:", err);
  }

  userCache = new Map();
  return userCache;
}

function saveUserCache(cache: Map<string, { name: string; avatar?: string }>): void {
  try {
    const dir = path.dirname(USER_CACHE_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    const obj = Object.fromEntries(cache.entries());
    fs.writeFileSync(USER_CACHE_FILE, JSON.stringify(obj, null, 2), "utf-8");
  } catch (err) {
    console.warn("[dingtalk] Failed to save user cache:", err);
  }
}

/** Get user info by userid (staffId), with persistent cache */
export async function getUserInfo(
  clientId: string,
  clientSecret: string,
  userid: string,
): Promise<{ name: string; avatar?: string } | null> {
  const cache = loadUserCache();

  // Check cache first
  const cached = cache.get(userid);
  if (cached) return cached;

  // Call DingTalk API
  try {
    const token = await getDingTalkAccessToken(clientId, clientSecret);
    const res = await jsonPost(
      `${DINGTALK_OAPI_BASE}/topapi/v2/user/get?access_token=${token}`,
      {
        userid,
        language: "zh_CN",
      },
    );

    if (res.errcode !== 0) {
      console.warn(`[dingtalk] Failed to get user info for ${userid}: ${res.errmsg}`);
      return null;
    }

    const userInfo = {
      name: res.result?.name || userid,
      avatar: res.result?.avatar,
    };

    // Save to cache
    cache.set(userid, userInfo);
    saveUserCache(cache);

    return userInfo;
  } catch (err) {
    console.warn(`[dingtalk] Error getting user info for ${userid}:`, err);
    return null;
  }
}

/** Batch get user info with timeout */
export async function batchGetUserInfo(
  clientId: string,
  clientSecret: string,
  userids: string[],
  timeoutMs: number = 500,
): Promise<Map<string, string>> {
  const result = new Map<string, string>();

  if (userids.length === 0) return result;

  const promises = userids.map(async (userid) => {
    const info = await getUserInfo(clientId, clientSecret, userid);
    if (info) {
      result.set(userid, info.name);
    }
  });

  try {
    await Promise.race([
      Promise.all(promises),
      new Promise((_, reject) => setTimeout(() => reject(new Error("timeout")), timeoutMs)),
    ]);
  } catch (err) {
    // Timeout or error - return partial results
    console.warn(`[dingtalk] Batch user info fetch timeout/error:`, err);
  }

  return result;
}
